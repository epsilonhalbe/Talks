<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Martin Heuschober" />
  <meta name="author" content="CC-BY-NC-SA 4.0" />
  <title>Ein bisschen wie LEGO®</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="reveal.js/css/reveal.min.css"/>
    <style type="text/css">code{white-space: pre;}</style>
    <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
    </style>
    <link rel="stylesheet" href="reveal.js/css/theme/simple.css" id="theme">
  <link rel="stylesheet" media="print" href="reveal.js/css/print/pdf.css" />
  <!--[if lt IE 9]>
  <script src="reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section>
    <h1 class="title">Ein bisschen wie LEGO<sup>®</sup></h1>
    <h2 class="author">Martin Heuschober</h2>
    <h2 class="author"><a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC-BY-NC-SA 4.0</a></h2>
    <h3 class="date">10. Mai 2014</h3>
</section>

<section class="slide level2">

<link rel="stylesheet" href="highlight.js/styles/solarized_light.css"> <link rel="stylesheet" href="reveal.js/css/reveal.css"/>
<script src="highlight.js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

</section>
<section><section id="about-me" class="titleslide slide level1"><h1>About me</h1></section><section id="martin-heuschober" class="slide level2">
<h1>Martin Heuschober</h1>
<ul>
<li>gelernter Mathematiker</li>
<li>Organisator der <a href="https://metalab.at/wiki/Lambdaheads">Lambdaheads</a>
<ul>
<li>Mittwoch, 14.5.2014, 19:30 -22:00</li>
<li>Inst. f. Mathe (Oskar Morgenstern Platz 1) Raum 1.141 (1.Stock)</li>
</ul></li>
<li>Haskell im Selbststudium</li>
<li>github: <a href="http://github.com/epsilonhalbe">epsilonhalbe</a></li>
<li><a href="http://github.com/epsilonhalbe/Talks/">slides</a> LikeLegos</li>
</ul>
</section></section>
<section><section id="intro" class="titleslide slide level1"><h1>Intro</h1></section><section id="warum-haskell-wie-lego" class="slide level2">
<h1>Warum Haskell wie Lego?</h1>
<p>Beim Vorbereiten meines Vortrags habe ich überlegt wie ich Leuten so etwas abstraktes wie Haskell erkläre, ohne dass ich Programmierkenntnisse voraussetze. Dabei ist mir beim Thema &quot;Immutability&quot; eine Stelle aus &quot;Sophies Welt&quot; eingefallen, in der das griechische Atommodell mit Lego verglichen wurde. Ausgehend von dieser Idee sind mir immer mehr Parallelen zwischen diesen beiden Dingen eingefallen und ihr müsst euch den Blödsinn jetzt anhören.</p>
</section><section id="schlagwörter" class="slide level2">
<h1>Schlagwörter</h1>
<ul>
<li>Pure</li>
<li>Stark typisiert</li>
<li>Statisch typisiert</li>
<li>Lazy</li>
<li>Funktional</li>
</ul>
</section></section>
<section><section id="haskell-ist-pure" class="titleslide slide level1"><h1>Haskell ist &quot;pure&quot;</h1></section><section id="pure" class="slide level2">
<h1>Pure</h1>
<p>Wie auch Legosteine sind Haskell Variablen unveränderlich, wer einen Baustein anderer Form/Farbe benötigt muss den alten wegwerfen (Garbage-Collecten) und einen neuen Baustein suchen/eine neue Instanz erzeugen.</p>
<p>Das heißt auch, dass Konstrukte und Abstraktionen anderer Programmiersprachen wie <code>for</code>-Schleifen oder <code>x++</code> nicht existieren.</p>
</section><section id="wie-löst-man-ebendiese-probleme" class="slide level2">
<h1>Wie löst man ebendiese Probleme?</h1>
<ul>
<li>Rekursion</li>
<li>Higher-Order-Functions</li>
<li>lokalen Variablen</li>
<li>Datenstrukturen wie Listen, Bäumen etc.</li>
</ul>
</section></section>
<section><section id="haskell-ist-stark-typisiert" class="titleslide slide level1"><h1>Haskell ist stark typisiert</h1></section><section id="stark-typisiert" class="slide level2">
<h1>Stark typisiert</h1>
<p>So wie jeder Legostein eine fixe Länge, Breite und Farbe hat, so besitzt alles in Haskell einen Typ. <code>Lego (1 × 4) Red</code> ist vom Typ Lego (geschrieben <code>:: Lego</code>). Diese Typen werden vom Compiler überprüft, d.h. wo in meinem Quellcode ein <code>Lego</code> erwartet wird kann ich keinen <code>Duplo</code> Baustein verwenden.</p>
</section><section id="beispiele" class="slide level2">
<h1>Beispiele</h1>
<p>Ein paar Beispiele die man am besten im Interpreter <code>ghci</code> ausprobiert. Also unter MSWindows <code>winghci.exe</code> ausführen oder unter Unix ein Terminal öffnen und <code>ghci</code> aufrufen.</p>
</section><section class="slide level2">

<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> a <span class="fu">=</span> <span class="ch">&#39;a&#39;</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span><span class="kw">type</span> a
<span class="ot">a ::</span> <span class="dt">Char</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> b <span class="fu">=</span> [<span class="ch">&#39;T&#39;</span>,<span class="ch">&#39;e&#39;</span>,<span class="ch">&#39;x&#39;</span>,<span class="ch">&#39;t&#39;</span>]
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t b
<span class="ot">b ::</span> [<span class="dt">Char</span>]
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> c <span class="fu">=</span> <span class="st">&quot;Text&quot;</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t c
<span class="ot">c ::</span> [<span class="dt">Char</span>]
<span class="dt">Prelude</span><span class="fu">&gt;</span> b <span class="fu">==</span> c
<span class="dt">True</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t b <span class="fu">==</span> c
b <span class="fu">==</span><span class="ot"> c ::</span> <span class="dt">Bool</span></code></pre>
</section></section>
<section><section id="haskell-ist-statisch-typisiert" class="titleslide slide level1"><h1>Haskell ist statisch typisiert</h1></section><section id="statisch-typisiert" class="slide level2">
<h1>Statisch typisiert</h1>
<p>Wo in anderen Programmiersprachen der Buchstabe <code>'a'</code> auch als Zahl verwendet werden kann und man <code>'a'+3</code> berechnen kann und <code>'d'</code> erwartet, erhält man in Haskell eine Fehlermeldung, dass der Operator <code>(+)</code> zwei Zahlen vom gleichen Typ erwartet.</p>
</section><section class="slide level2">

<p>Auch die <code>putStrLn</code>-Funktion erwartet einen <code>String</code>, den sie auf der Kommandozeile ausgibt und macht <strong>keine</strong> implizite Umwandlung, d.h.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> putStrLn <span class="dv">3</span>
<span class="co">--lange Errormessage</span></code></pre>
</section><section id="alles-hat-einen-typ" class="slide level2">
<h1>Alles hat einen Typ</h1>
<p>Auch Funktionen haben einen und der wird in einer Datei z.B. <code>MyFile.hs</code> meistens dazugeschrieben:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
f x y <span class="fu">=</span> <span class="dv">2</span> <span class="fu">*</span> x <span class="fu">+</span> y</code></pre>
<ul>
<li><code>f :: Int -&gt; Int -&gt; Int</code><br> heißt: <code>f</code> nimmt einen <code>Int</code> und auch einen zweiten <code>Int</code> und liefert (das ist immer das letzte Dings in so einer Zeile) einen <code>Int</code></li>
<li>man verwendet Klammern nur da wo sie notwendig sind</li>
</ul>
</section><section id="eigene-typen" class="slide level2">
<h1>Eigene Typen</h1>
<p>Haskell erlaubt es auch sich eigene Typen auszudenken.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Color</span> <span class="fu">=</span> <span class="dt">Black</span> <span class="fu">|</span> <span class="dt">Red</span>     <span class="fu">|</span> <span class="dt">Green</span> <span class="fu">|</span> <span class="dt">Yellow</span>
           <span class="fu">|</span> <span class="dt">Blue</span>  <span class="fu">|</span> <span class="dt">Magenta</span> <span class="fu">|</span> <span class="dt">Cyan</span>  <span class="fu">|</span> <span class="dt">White</span>
<span class="kw">data</span> <span class="dt">Dimension</span> <span class="fu">=</span> <span class="dt">Dim</span> {<span class="ot">x ::</span> <span class="dt">Int</span>,<span class="ot"> y ::</span> <span class="dt">Int</span>}
<span class="kw">data</span> <span class="dt">Lego</span> <span class="fu">=</span> <span class="dt">Lego</span> {<span class="ot">dim ::</span> <span class="dt">Dimension</span>,<span class="ot"> color ::</span> <span class="dt">Color</span>}</code></pre>
</section></section>
<section><section id="haskell-ist-funktional" class="titleslide slide level1"><h1>Haskell ist funktional</h1></section><section id="funktional" class="slide level2">
<h1>Funktional</h1>
<p>Funktionen haben keinen besonderen Status, man kann sie wie jeden anderen Typ in Variablen speichern, in Listen packen oder als Parameter in anderen Funktionen verwenden.</p>
</section><section id="wtf-ist-funktional-in-lego" class="slide level2">
<h1>WTF ist Funktional in LEGO</h1>
<p>Baupläne! Baupläne sind genauso wie Haskell-Funktionen, immer gleich. Soll heißen wenn ich einen Bauplan zwei mal hintereinander ausführe kommt das geiche Modell heraus bzw. bei Haskell der gleiche Wert.</p>
<p>Weiters werden in Baupläne kleine Teilbaupläne verwendet - auch in Haskell-Funktionen werden kleinere Funktionen als &quot;Bausteine&quot; verwendet.</p>
</section><section id="beispiele-1" class="slide level2">
<h1>Beispiele</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> a x <span class="fu">=</span> <span class="dv">10</span><span class="fu">*</span>x
<span class="dt">Prelude</span><span class="fu">&gt;</span> a <span class="dv">10</span>
<span class="dv">100</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> b <span class="fu">=</span> (<span class="fu">+</span>)
<span class="dt">Prelude</span><span class="fu">&gt;</span> b <span class="dv">1</span> <span class="dv">2</span>
<span class="dv">3</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> c <span class="fu">=</span> \x <span class="ot">-&gt;</span> x<span class="fu">*</span><span class="dv">2</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> c <span class="dv">1</span>
<span class="dv">2</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> d <span class="fu">=</span> \x y <span class="ot">-&gt;</span> x<span class="fu">*</span>y
<span class="dt">Prelude</span><span class="fu">&gt;</span> d <span class="dv">2</span> <span class="dv">3</span>
<span class="dv">6</span></code></pre>
</section></section>
<section><section id="haskell-ist-lazy" class="titleslide slide level1"><h1>Haskell ist &quot;lazy&quot;</h1></section><section id="lazy" class="slide level2">
<h1>Lazy</h1>
<p>So wie beim Bau eines Lego-Hauses, wo ich ein Bauteil erst dann suche wenn ich es benötige, wird auch in Haskell Zeug erst dann ausgewertet wenn es gebraucht wird.</p>
</section><section class="slide level2">

<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> a <span class="fu">=</span> <span class="dv">3</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>sprint a
a <span class="fu">=</span> <span class="dv">3</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> b <span class="fu">=</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>]
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>sprint b
b <span class="fu">=</span> _
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> c <span class="fu">=</span> map (<span class="fu">*</span><span class="dv">2</span>) b
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>sprint c
c <span class="fu">=</span> _
<span class="dt">Prelude</span><span class="fu">&gt;</span> length c
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>sprint b
b <span class="fu">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>]
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>sprint c
c <span class="fu">=</span> [_,_,_,_,_,_,_,_,_,_]</code></pre>
</section><section id="nochmal-lazyness-in-action" class="slide level2">
<h1>Nochmal lazyness in Action</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> fib <span class="fu">=</span> <span class="dv">1</span><span class="fu">:</span><span class="dv">1</span><span class="fu">:</span>zipWith (<span class="fu">+</span>) fib (tail fib)
<span class="dt">Prelude</span><span class="fu">&gt;</span> take <span class="dv">10</span> fib
[<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">8</span>,<span class="dv">13</span>,<span class="dv">21</span>,<span class="dv">34</span>,<span class="dv">55</span>]</code></pre>
</section></section>
<section><section id="noch-einmal-legos" class="titleslide slide level1"><h1>Noch einmal Legos</h1></section><section id="ghci" class="slide level2">
<h1>GHCi</h1>
<pre class="sourceCode bash"><code class="sourceCode bash">$<span class="kw">&gt;</span> <span class="kw">ghci</span> LikeLegos.hs</code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">let</span> lego <span class="fu">=</span> <span class="dt">Lego</span> (<span class="dv">1</span>×4)
<span class="kw">let</span> colors <span class="fu">=</span> [<span class="dt">Black</span> <span class="fu">..</span> <span class="dt">White</span>]
map lego colors
pprint <span class="fu">$</span> map lego colors
pprint <span class="fu">$</span> map lego (colors <span class="fu">++</span> colors)
pprint <span class="fu">$</span> map lego (colors <span class="fu">++</span> reverse colors)
pprint <span class="fu">$</span> map lego (colors <span class="fu">++</span> tail (reverse colors))
<span class="kw">let</span> legos <span class="fu">=</span> map lego (colors <span class="fu">++</span> tail (reverse colors))</code></pre>
</section><section class="slide level2">

<pre class="sourceCode haskell"><code class="sourceCode haskell">pprint <span class="fu">$</span> map (setX <span class="dv">2</span>) <span class="fu">$</span> legos&#39;
pprint <span class="fu">$</span> map (setColor <span class="dt">Red</span> <span class="fu">.</span> setX <span class="dv">2</span>) legos&#39;
pprint <span class="fu">$</span> zipWith setY [<span class="dv">1</span><span class="fu">..</span>] (map (setColor <span class="dt">Red</span>) legos&#39;)
pprint <span class="fu">$</span> zipWith setY ([<span class="dv">1</span><span class="fu">..</span><span class="dv">8</span>]<span class="fu">++</span>[<span class="dv">7</span>,<span class="dv">6</span><span class="fu">..</span><span class="dv">1</span>]) legos&#39;
pprint <span class="fu">$</span> zipWith setY (map (\x <span class="ot">-&gt;</span> <span class="dv">9</span><span class="fu">-</span>x) ([<span class="dv">1</span><span class="fu">..</span><span class="dv">8</span>]<span class="fu">++</span>[<span class="dv">7</span>,<span class="dv">6</span><span class="fu">..</span><span class="dv">1</span>])) legos&#39;</code></pre>
</section></section>
<section><section id="was-brauche-ich-zum-herumspielen" class="titleslide slide level1"><h1>Was brauche ich zum herumspielen?</h1></section><section id="compiler" class="slide level2">
<h1>Compiler</h1>
<ul>
<li>Einen funktionierenden Compiler/Interpreter am besten Haskell-Platform <a href="http://www.haskell.org">herunterladen</a> und installieren</li>
<li>Compiler gibt es mehrere, der mit Abstand populärste ist GHC</li>
<li>Interpreter gibt es auch einige, aber außer GHCi sind alle veraltet</li>
</ul>
</section><section id="editor" class="slide level2">
<h1>Editor</h1>
<ul>
<li>Vim + Plugins (Syntastic, ghc-mod, haskellmode, hdevtools, lushtags)</li>
<li>Emacs + Plugins (ghc-mod)</li>
<li>Eclipse + EclipseFP</li>
<li>FPComplete hat einen online editor</li>
</ul>
</section><section id="bücher" class="slide level2">
<h1>Bücher</h1>
<ul>
<li><a href="http://learnyouahaskell.com">Learn you a haskell for great good</a> (short lyah)</li>
<li><a href="http://book.realworldhaskell.org/read/">Real World Haskell</a></li>
<li><a href="http://chimera.labs.oreilly.com/books/1230000000929/index.html">Parallel and Concurrent Programming in Haskell</a></li>
<li><a href="http://www.yesodweb.com/">Haskell and Yesod</a></li>
</ul>
</section><section id="blogs-podcasts" class="slide level2">
<h1>Blogs &amp; Podcasts</h1>
<ul>
<li><a href="http://planet.haskell.org/">Planet Haskell</a> eine Sammlung von aktuellen Blogartikeln</li>
<li><a href="http://www.reddit.com/r/haskell">Reddit</a></li>
<li><a href="http://www.haskellcast.com/">Haskellcast</a></li>
<li>haskell-cafe - mailinglist</li>
<li><a href="https://metalab.at/wiki/Lambdaheads">Lambdaheads</a></li>
</ul>
</section><section id="sonstige-tools" class="slide level2">
<h1>Sonstige Tools</h1>
<ul>
<li>HLint - ein ausgezeichnetes Tool das Codestyle verbessert</li>
<li><a href="http://hackage.haskell.org/">Hackage</a></li>
<li>Cabal - der Paketmanager von Haskell</li>
<li>Hoogle - eine Suchmaschine die es ermöglicht nach Funktionen zu suchen</li>
<li>Hayoo - noch eine Suchmaschine, die noch mehr Pakete durchsucht</li>
<li><a href="http://stackoverflow.com/questions/tagged/haskell">www.stackoverflow.com</a></li>
</ul>
</section></section>
    </div>
  </div>

  <script src="reveal.js/lib/js/head.min.js"></script>
  <script src="reveal.js/js/reveal.min.js"></script>

  <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,
        theme: 'solarized', // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
//          { src: 'reveal.js/plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; }, }
//          { src: 'reveal.js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
]});
    </script>
  </body>
</html>
